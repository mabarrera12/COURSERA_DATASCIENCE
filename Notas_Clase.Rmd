---
title: "Class Notes"
author: "Alejandra Barrera"
date: "6/1/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```
<style type="text/css">
.main-container {
  max-width: auto;
  margin-left: 50px;
  margin-right: 50px;
}
</style>

## Semana 1

Notas para la futura Alejandra. Recuerda **SIEMPRE** estos pasos: Guardar->Commit->Push (asi se hayan desaparecido los archivos) y ya. Puedes usar esta pagina donde estan las referencias de R Markdown.

[PAGINA_Referencias](https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)   
[NOTAS DE LA SEMANA 2](./Notas_Clase_sem2.html)  
Para borrar la consola cntrl+L y para borrar todas las variables rm(list=ls()). Para tener informacion de una funcion se pone "?_funcion si parentesis_"

> There are different types of classes of objetcs  

  - character  
  - numeric  
  - integer  
  - complex  
  - Logical  

La excepcion es una lista que puede tener cualquier objeto. 

### __*Vectores, Matrices, listas, factores, dataframe...*__  
<details>  
  <summary> Click to expand! </summary>  
 
#### Vectores
> Con la funcion c()  

```{r}
x<- c(0.5, 0.6) #Como si c significara concatenar
print(x)
```
Tambien pueden tener nombres propios
```{r}
names(x)<-c("Food","Bar")
x
```
En este caso, pueden haber distintos objetos (numericos, logicos, enteros, etc)

> Con la funcion vector() 

```{r}
x<-vector("numeric", length=10)
x
```
***
Para saber la clase entonces se usa *class()*
```{r}
class(x)
```
Se puede forzar la conversion entre clases de numeros. Por ejemplo:
```{r}
x<-0:6
class(x)
as.numeric(x)
as.character(x)
as.logical(x)
```
 
#### Listas
```{r}
x<-list(1, "a", TRUE, 1+4i) #Recuerda que los numeros que cambian son los indices de los vectores, tienen dobles corchetes cuadrados
print(x)
```
Tambien pueden tener nombres
```{r}
x<-list(a=1,b= "a",c= TRUE,d= 1+4i)
x
```
#### Matrices
```{r}
m<- matrix(1:6,nrow=2, ncol=3) # Se construye column wise
print(m)
dim(m)
attributes(m) #Todo lo que se le pueda sacar
m[1,] #Para extraer solo la primera fila

```
Tambien pueden tener nombres:
```{r}
dimnames(m) <- list(c("fila1","fila2"),c("col1","col2","col3")) #Se usa una listaaa
m
```

* Otra forma es redimensionar un vector
```{r}
m<-1:10
dim(m) <- c(2,5) #dos filas, dos columnas
m
```
* Cbind-ing and rbind-ing
```{r}
x<-1:3
y<-10:12
cbind(x,y) # Los une por columnas
print("Tambien se puede unir por filas")
rbind(x,y)
```

#### Factors
Para tener datos categoricos:
```{r}
x<-factor(c("yes","no","yes", "no"), levels = c("yes","no")) #Para determinar el orden de los niveles.

x
table(x) #Conteo
class(x)
```

#### Data Frame
```{r}
x<-data.frame(food=1:4, bar=c(T,T,F,F))
x
nrow(x)
ncol(x)
```
</details>  

### __*Texto*__  
<details>  
  <summary> Click to expand! </summary>  
 
Para convertir vectores a caracteres unidos
```{r}
paste(as.character(c(rep(0,times=3-length(1)),1)), collapse ="")
```
</details> 

### __*Operaciones de Vectores*__  
<details>  
  <summary> Click to expand! </summary>    

When given two vectors of the same length, R simply performs the specified arithmetic operation (`+`, `-`,
| `*`, etc.) element-by-element. If the vectors are of different lengths, R 'recycles' the shorter vector
| until it is the same length as the longer vector.
```{r}
x<-1:4; y<-6:9
x+y
x/y #element wise
x*y #element wise
x%*% y #true matriz multiplication
```
</details>  

### __*Functions*__    
<details>  
  <summary> Click to expand! </summary>  
  
#### Forma general
Para ver los argumentos de una funcion se usa args(Nombre de la funcion)
```{r}
above_10 <- function (x, n=10){
  use <- x>n
  x[use]
  # Se puede especificar default values.
}
above_10(c(1,4,6,8,99))

```
#### Funciones anonimas
Con la funcion _lapply_ o similares se pueden aplicar funciones creadas en el momento. _sapply_ simplifica los resultados, si todos los resultados son unitarios se retorna un vector.   
```{r}
x<-list(a=matrix(1:4, 2,2), b=matrix(1:6,3,2))
print(x)
lapply(x, function(elt) elt[,1])
```
_apply_ se usa para evaluar una fucnion en los margenes de un arreglo.
```
str(apply)
function(X, margin, function, ...)
```
Por ejemplo:
```{r}
x<-matrix(rnorm(200),20,10)
apply(x,2,mean) #dimension 2 is cols. El promedio se hace vertical
apply(x,1,sum)  #Sum through the rows 
```
Hay funciones como rowsum, o colsum que pueden reducir el codigo.   

_mapply_ is a multivariate apply of sorts.  
```
str(mapply)
function(FUN,..., MoreArgs=NULL, SIMPLIFY=TRUE. USE.NAMES=TRUE)
```
  *  FUN is a function to apply
  * ... contains arguments to apply over  
  * MoreArgs is a list of other arguments to FUN
  * SIMPLIFY indicates whether the result should be simplyfied  
  
Por ejemplo, en vez de usar `list(rep(1,4), rep(2,3), rep(3,2), rep(4,1))` se puede usar:
```{r}
mapply(rep,1:4,4:1)
```
_tapply_ is used to apply a function over subsets of a vector  
```
str(tapply)
function(X, index, FUN=NUL,..., SIMPLIFY=TRUE )
```
  * X is a vector 
  * INDEX is a factor or a list of factors
  * FUN is a function to apply
  * ... contains arguments to apply over  
  * SIMPLIFY indicates whether the result should be simplyfied  
```{r}
x<-c(rnorm(10), runif(10),rnorm(10))
f<-gl(3,10) #Genera los niveles de los factores gl(n,k) n es el numero de niveles y k el numero de replicas
tapply(x,f,mean)
```

_split_ takes a vector or other objetc and splits it into groups determined by a factor of list of factors
```
str(split)
function(x, f, drop=FALSE,... )
```
  * x is a vector or data frame  
  * f is a factores or a list of factors
  * drop indicates whether empty factors levels should be dropped

```{r}
split(x,f) #siempre devuelve una lista. Se puede usar con otra function
lapply(split(x,f),mean)
```
</details>  
  

